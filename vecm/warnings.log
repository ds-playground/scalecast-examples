WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 19, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 21, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 41, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 30}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 33, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 25, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 23, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 30}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 30, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 14, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 56, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 55, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 24, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 51, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 0}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 0}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 2, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: No frequency information was provided with date index and no frequency could be inferred.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 3, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: list index out of range
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the vecm model
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 0, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 42, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 65, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 37, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 5, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 22, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 45, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 0, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 0, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 22, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 0, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 28, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 28, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 31, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 30, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the vecm model
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 0, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 35, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 30, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 5, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 6, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 30, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 41, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 2, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 30, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 65, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 4, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 30, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 41, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 65, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 23, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 0, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 42, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: Unable to allocate 798. PiB for an array with shape (112320000000000000,) and data type int64
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0, 'freq': 'ns'}. error: list index out of range
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the vecm model
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 55, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 13, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 14, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 30, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 5, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 55, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 49, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 54, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 8, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 5, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 12, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 49, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 46, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 11, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the vecm model
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 25, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 58, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 5, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 56, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 0, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 28, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 5, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 0, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 34, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 21, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 65, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 25, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 55, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 0, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 30, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 0, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 30, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 65, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 47, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 54, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 62, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 14, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 30, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: Invalid frequency: BD
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'BD'}. error: list index out of range
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the vecm model
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 4, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 50, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 14, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 9, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 37, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 12, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 16, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 33, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 54, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 39, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 49, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 18, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 0, 'freq': 'D'}. error: list index out of range
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the vecm model
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 31, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 14, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 13, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 23, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 57, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 7, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 27, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 45, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 45, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 35, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 2, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 57, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 0, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 44, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: The given frequency argument could not be matched to the given index.
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'D'}. error: list index out of range
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the vecm model
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\base\tsa_model.py:471: ValueWarning: No frequency information was provided, so inferred frequency B will be used.
  self._init_dates(dates, freq)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 46, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: overflow encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 27, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 27, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 27, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 27, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 54, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 31, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 57, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 56, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 42, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 55, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: overflow encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 44, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 50, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 50, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 50, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 50, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 21, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 21, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 8, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 8, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 8, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 8, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 50, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 42, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 33, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 55, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 22, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 59, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 57, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 33, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 40, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 21, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 33, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 10, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 61, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 30, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 61, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 25, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 21, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 29, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 49, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 49, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: overflow encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 51, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 54, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 33, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 30, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 51, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 48, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 0, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 38, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 57, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 37, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 47, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 37, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 62, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 65, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 53, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 57, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 15, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 5, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 51, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 16, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260, 'freq': 'B'}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 25, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 35, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260, 'freq': 'B'}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'k_ar_diff': 17, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 30, 'freq': 'B'}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 53, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 57, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 23, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 26, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: Singular matrix
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 33, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 55, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 44, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 15, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 26, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 30, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 65}. error: list index out of range
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 44, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 33, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 5}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 54, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 28, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 36, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 40, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 25, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 63, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 0}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 0}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 19, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 63, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 44, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 43, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 29, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 5}. error: list index out of range
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.496e+03, tolerance: 2.103e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.153e+03, tolerance: 4.575e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.302e+04, tolerance: 9.373e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.752e+02, tolerance: 1.482e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.045e+04, tolerance: 2.093e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.279e+03, tolerance: 4.565e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.669e+04, tolerance: 9.351e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.374e+02, tolerance: 1.477e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.863e+03, tolerance: 2.102e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.189e+03, tolerance: 4.574e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.465e+04, tolerance: 9.373e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.978e+02, tolerance: 1.482e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.046e+04, tolerance: 2.101e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.278e+03, tolerance: 4.573e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.670e+04, tolerance: 9.367e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.378e+02, tolerance: 1.481e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.054e+04, tolerance: 2.111e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.305e+03, tolerance: 4.616e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.684e+04, tolerance: 9.378e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.435e+02, tolerance: 1.489e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.864e+03, tolerance: 2.101e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.171e+03, tolerance: 4.573e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.445e+04, tolerance: 9.369e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.919e+02, tolerance: 1.481e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.732e+03, tolerance: 2.102e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.168e+03, tolerance: 4.574e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.416e+04, tolerance: 9.373e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.888e+02, tolerance: 1.482e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.182e+03, tolerance: 2.088e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.017e+03, tolerance: 4.562e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.181e+04, tolerance: 9.346e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.497e+02, tolerance: 1.475e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.329e+03, tolerance: 2.084e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.044e+03, tolerance: 4.559e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.215e+04, tolerance: 9.333e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.601e+02, tolerance: 1.474e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.040e+04, tolerance: 2.089e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.271e+03, tolerance: 4.563e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.658e+04, tolerance: 9.350e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.350e+02, tolerance: 1.476e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.415e+03, tolerance: 2.088e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.073e+03, tolerance: 4.562e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.276e+04, tolerance: 9.347e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.668e+02, tolerance: 1.476e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.771e+03, tolerance: 2.100e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.151e+03, tolerance: 4.571e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.412e+04, tolerance: 9.365e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.856e+02, tolerance: 1.480e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.415e+03, tolerance: 9.999e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.658e+02, tolerance: 1.718e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.951e+04, tolerance: 4.403e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.123e+02, tolerance: 7.424e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.935e+03, tolerance: 9.902e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.513e+02, tolerance: 1.708e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.182e+04, tolerance: 4.380e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.673e+02, tolerance: 7.376e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.573e+03, tolerance: 9.985e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.944e+02, tolerance: 1.717e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.021e+04, tolerance: 4.403e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.276e+02, tolerance: 7.424e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.954e+03, tolerance: 9.982e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.516e+02, tolerance: 1.716e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.180e+04, tolerance: 4.397e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.671e+02, tolerance: 7.416e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.027e+03, tolerance: 1.008e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.775e+02, tolerance: 1.759e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.197e+04, tolerance: 4.408e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.732e+02, tolerance: 7.490e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.573e+03, tolerance: 9.982e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.898e+02, tolerance: 1.716e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.011e+04, tolerance: 4.399e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.239e+02, tolerance: 7.417e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.497e+03, tolerance: 9.985e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.823e+02, tolerance: 1.717e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.990e+04, tolerance: 4.403e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.210e+02, tolerance: 7.424e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.143e+03, tolerance: 9.847e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.050e+02, tolerance: 1.705e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.832e+04, tolerance: 4.376e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.931e+02, tolerance: 7.350e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.232e+03, tolerance: 9.813e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.230e+02, tolerance: 1.703e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.868e+04, tolerance: 4.363e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.032e+02, tolerance: 7.338e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.889e+03, tolerance: 9.860e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.457e+02, tolerance: 1.706e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.170e+04, tolerance: 4.379e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.644e+02, tolerance: 7.363e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.275e+03, tolerance: 9.853e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.327e+02, tolerance: 1.705e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.894e+04, tolerance: 4.377e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.058e+02, tolerance: 7.360e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.491e+03, tolerance: 9.968e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.734e+02, tolerance: 1.714e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.982e+04, tolerance: 4.395e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.196e+02, tolerance: 7.402e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.114e+03, tolerance: 4.828e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.761e+02, tolerance: 8.854e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.201e+03, tolerance: 2.232e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.052e+02, tolerance: 2.508e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.355e+03, tolerance: 4.733e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.351e+02, tolerance: 8.760e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.096e+04, tolerance: 2.209e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.222e+02, tolerance: 2.459e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.238e+03, tolerance: 4.815e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.054e+02, tolerance: 8.851e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.004e+04, tolerance: 2.232e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.133e+02, tolerance: 2.508e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.385e+03, tolerance: 4.812e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.370e+02, tolerance: 8.836e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.096e+04, tolerance: 2.226e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.235e+02, tolerance: 2.500e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.449e+03, tolerance: 4.909e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.621e+02, tolerance: 9.268e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.114e+04, tolerance: 2.236e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.283e+02, tolerance: 2.574e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.227e+03, tolerance: 4.812e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.018e+02, tolerance: 8.840e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.813e+03, tolerance: 2.227e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.108e+02, tolerance: 2.501e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.187e+03, tolerance: 4.815e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.949e+02, tolerance: 8.851e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.770e+03, tolerance: 2.232e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.105e+02, tolerance: 2.508e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.872e+03, tolerance: 4.677e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.153e+02, tolerance: 8.727e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.044e+03, tolerance: 2.204e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.104e+01, tolerance: 2.433e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.920e+03, tolerance: 4.642e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.294e+02, tolerance: 8.703e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.305e+03, tolerance: 2.191e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.432e+01, tolerance: 2.421e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.314e+03, tolerance: 4.689e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.293e+02, tolerance: 8.734e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.084e+04, tolerance: 2.208e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.204e+02, tolerance: 2.447e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.984e+03, tolerance: 4.682e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.412e+02, tolerance: 8.730e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.632e+03, tolerance: 2.206e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.779e+01, tolerance: 2.444e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.170e+03, tolerance: 4.797e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.809e+02, tolerance: 8.822e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.447e+03, tolerance: 2.224e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.071e+02, tolerance: 2.486e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 50, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 53, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 10, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 53, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 20, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 0}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 0}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 22, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 5}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 44, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 6, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 6, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 6, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 6, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 6, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 6, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 65}. error: list index out of range
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\metrics\_regression.py:796: UndefinedMetricWarning: R^2 score is not well-defined with less than two samples.
  warnings.warn(msg, UndefinedMetricWarning)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.440e+03, tolerance: 1.988e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.075e+03, tolerance: 4.304e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.413e+04, tolerance: 9.197e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.645e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.917e+03, tolerance: 1.971e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.738e+03, tolerance: 4.289e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.730e+04, tolerance: 9.164e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.548e+02, tolerance: 1.391e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.770e+03, tolerance: 1.967e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.130e+03, tolerance: 4.287e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.552e+04, tolerance: 9.153e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.903e+02, tolerance: 1.389e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.956e+03, tolerance: 1.973e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.766e+03, tolerance: 4.291e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.749e+04, tolerance: 9.171e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.544e+02, tolerance: 1.393e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.178e+03, tolerance: 1.985e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.826e+03, tolerance: 4.301e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.890e+04, tolerance: 9.190e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.614e+02, tolerance: 1.398e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.014e+03, tolerance: 1.988e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.021e+03, tolerance: 4.304e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.222e+04, tolerance: 9.197e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.353e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.774e+03, tolerance: 1.988e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.984e+03, tolerance: 4.303e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.145e+04, tolerance: 9.196e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.175e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.851e+03, tolerance: 1.985e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.985e+03, tolerance: 4.302e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.149e+04, tolerance: 9.194e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.218e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.938e+03, tolerance: 1.987e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.015e+03, tolerance: 4.303e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.198e+04, tolerance: 9.196e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.315e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.669e+03, tolerance: 7.607e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.511e+02, tolerance: 1.351e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.710e+04, tolerance: 3.566e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.249e+02, tolerance: 4.701e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.004e+03, tolerance: 7.439e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.032e+02, tolerance: 1.336e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.338e+04, tolerance: 3.533e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.817e+02, tolerance: 4.622e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.672e+03, tolerance: 7.398e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.608e+02, tolerance: 1.334e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.745e+04, tolerance: 3.522e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.283e+02, tolerance: 4.601e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.080e+03, tolerance: 7.460e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.249e+02, tolerance: 1.339e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.386e+04, tolerance: 3.540e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.867e+02, tolerance: 4.638e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.203e+03, tolerance: 7.583e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.577e+02, tolerance: 1.349e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.464e+04, tolerance: 3.559e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.895e+02, tolerance: 4.692e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.546e+03, tolerance: 7.607e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.291e+02, tolerance: 1.351e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.655e+04, tolerance: 3.566e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.167e+02, tolerance: 4.701e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.446e+03, tolerance: 7.607e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.125e+02, tolerance: 1.351e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.611e+04, tolerance: 3.565e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.107e+02, tolerance: 4.701e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.467e+03, tolerance: 7.585e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.139e+02, tolerance: 1.350e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.612e+04, tolerance: 3.563e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.118e+02, tolerance: 4.696e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.516e+03, tolerance: 7.601e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.233e+02, tolerance: 1.351e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.639e+04, tolerance: 3.565e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.138e+02, tolerance: 4.700e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.078e+03, tolerance: 4.438e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.648e+02, tolerance: 7.800e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.262e+03, tolerance: 2.030e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.036e+02, tolerance: 2.275e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.405e+03, tolerance: 4.270e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.101e+02, tolerance: 7.656e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.276e+03, tolerance: 1.997e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.296e+01, tolerance: 2.195e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.068e+03, tolerance: 4.225e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.709e+02, tolerance: 7.634e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.628e+03, tolerance: 1.986e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.056e+02, tolerance: 2.172e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.479e+03, tolerance: 4.291e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.095e+02, tolerance: 7.677e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.605e+03, tolerance: 2.005e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.613e+01, tolerance: 2.211e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.545e+03, tolerance: 4.414e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.472e+02, tolerance: 7.780e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.052e+03, tolerance: 2.024e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.100e+01, tolerance: 2.266e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.924e+03, tolerance: 4.438e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.352e+02, tolerance: 7.800e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.450e+03, tolerance: 2.030e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.424e+01, tolerance: 2.275e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.820e+03, tolerance: 4.438e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.130e+02, tolerance: 7.799e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.861e+03, tolerance: 2.030e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.907e+01, tolerance: 2.275e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.855e+03, tolerance: 4.415e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.110e+02, tolerance: 7.788e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.736e+03, tolerance: 2.027e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.920e+01, tolerance: 2.269e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.899e+03, tolerance: 4.430e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.237e+02, tolerance: 7.799e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.110e+03, tolerance: 2.029e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.130e+01, tolerance: 2.273e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.625e+04, tolerance: 3.944e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.314e+03, tolerance: 8.059e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.237e+04, tolerance: 1.473e+01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.254e+03, tolerance: 3.052e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.718e+04, tolerance: 4.111e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.688e+03, tolerance: 8.827e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.480e+04, tolerance: 1.507e+01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.429e+03, tolerance: 3.474e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:root:could not evaluate the paramaters: {'max_depth': 2, 'Xvars': ['t', 'dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'weeksin', 'weekcos', 'dayofweeksin', 'dayofweekcos']}. error: X has 7 features, but MinMaxScaler is expecting 9 features as input.
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the rf model
WARNING:root:could not evaluate the paramaters: {'max_depth': 2, 'Xvars': ['dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'weeksin', 'weekcos', 'dayofweeksin', 'dayofweekcos']}. error: X has 6 features, but MinMaxScaler is expecting 8 features as input.
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the rf model
WARNING:root:could not evaluate the paramaters: {'max_depth': 2, 'Xvars': ['lnt', 'dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'weeksin', 'weekcos', 'monthsin', 'monthcos', 'quartersin', 'quartercos', 'dayofweeksin', 'dayofweekcos']}. error: X has 11 features, but MinMaxScaler is expecting 13 features as input.
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the rf model
WARNING:root:could not evaluate the paramaters: {'max_depth': 2, 'Xvars': ['dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'weeksin', 'weekcos', 'monthsin', 'monthcos', 'quartersin', 'quartercos', 'dayofweeksin', 'dayofweekcos']}. error: X has 10 features, but MinMaxScaler is expecting 12 features as input.
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the rf model
WARNING:root:could not evaluate the paramaters: {'max_depth': 2, 'Xvars': ['lnt', 'dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'weeksin', 'weekcos']}. error: X has 7 features, but MinMaxScaler is expecting 11 features as input.
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the rf model
WARNING:root:could not evaluate the paramaters: {'max_depth': 2, 'Xvars': ['dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'dayofweeksin', 'dayofweekcos', 'daysin', 'daycos', 'weeksin', 'weekcos']}. error: X has 6 features, but MinMaxScaler is expecting 10 features as input.
WARNING:root:none of the keyword/value combos stored in the grid could be evaluated for the rf model
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.056e+03, tolerance: 1.967e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.556e+03, tolerance: 4.288e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.322e+04, tolerance: 9.155e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.897e+02, tolerance: 1.390e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.858e+03, tolerance: 1.988e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.980e+03, tolerance: 4.304e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.180e+04, tolerance: 9.197e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.231e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.173e+03, tolerance: 1.973e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.797e+03, tolerance: 4.291e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.873e+04, tolerance: 9.171e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.682e+02, tolerance: 1.393e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.059e+03, tolerance: 1.985e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.998e+03, tolerance: 4.302e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.249e+04, tolerance: 9.193e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.331e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.407e+03, tolerance: 1.984e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.891e+03, tolerance: 4.300e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.999e+04, tolerance: 9.188e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.815e+02, tolerance: 1.397e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.806e+03, tolerance: 1.968e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.137e+03, tolerance: 4.288e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.565e+04, tolerance: 9.156e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.928e+02, tolerance: 1.391e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.322e+03, tolerance: 1.983e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.846e+03, tolerance: 4.298e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.956e+04, tolerance: 9.188e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.752e+02, tolerance: 1.397e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.799e+03, tolerance: 1.977e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.130e+03, tolerance: 4.294e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.557e+04, tolerance: 9.173e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.909e+02, tolerance: 1.394e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.762e+03, tolerance: 7.404e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.432e+02, tolerance: 1.335e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.184e+04, tolerance: 3.524e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.641e+02, tolerance: 4.607e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.451e+03, tolerance: 7.607e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.130e+02, tolerance: 1.351e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.610e+04, tolerance: 3.566e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.108e+02, tolerance: 4.701e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.068e+03, tolerance: 7.460e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.309e+02, tolerance: 1.339e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.402e+04, tolerance: 3.541e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.881e+02, tolerance: 4.638e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.516e+03, tolerance: 7.584e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.211e+02, tolerance: 1.349e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.627e+04, tolerance: 3.562e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.130e+02, tolerance: 4.693e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.284e+03, tolerance: 7.569e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.753e+02, tolerance: 1.347e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.509e+04, tolerance: 3.557e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.970e+02, tolerance: 4.678e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.693e+03, tolerance: 7.415e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.645e+02, tolerance: 1.336e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.754e+04, tolerance: 3.525e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.297e+02, tolerance: 4.614e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.262e+03, tolerance: 7.566e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.653e+02, tolerance: 1.345e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.483e+04, tolerance: 3.557e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.943e+02, tolerance: 4.673e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.717e+03, tolerance: 7.503e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.633e+02, tolerance: 1.341e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.752e+04, tolerance: 3.543e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.302e+02, tolerance: 4.651e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.078e+03, tolerance: 4.232e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.312e+02, tolerance: 7.643e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.346e+03, tolerance: 1.988e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.217e+01, tolerance: 2.178e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.822e+03, tolerance: 4.438e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.188e+02, tolerance: 7.800e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.058e+03, tolerance: 2.030e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.976e+01, tolerance: 2.275e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.471e+03, tolerance: 4.291e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.280e+02, tolerance: 7.678e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.976e+03, tolerance: 2.005e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.862e+01, tolerance: 2.211e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.913e+03, tolerance: 4.415e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.291e+02, tolerance: 7.785e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.261e+03, tolerance: 2.026e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.324e+01, tolerance: 2.266e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.689e+03, tolerance: 4.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.691e+02, tolerance: 7.766e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.579e+03, tolerance: 2.022e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.739e+01, tolerance: 2.251e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.098e+03, tolerance: 4.244e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.764e+02, tolerance: 7.648e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.774e+03, tolerance: 1.989e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.077e+02, tolerance: 2.187e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.655e+03, tolerance: 4.395e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.572e+02, tolerance: 7.744e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.390e+03, tolerance: 2.022e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.450e+01, tolerance: 2.246e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.116e+03, tolerance: 4.335e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.733e+02, tolerance: 7.704e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.676e+03, tolerance: 2.007e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.075e+02, tolerance: 2.225e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.430e+04, tolerance: 3.941e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.920e+03, tolerance: 8.058e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.578e+04, tolerance: 1.472e+01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.097e+03, tolerance: 3.050e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.529e+04, tolerance: 4.108e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.263e+03, tolerance: 8.826e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.831e+04, tolerance: 1.506e+01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.260e+03, tolerance: 3.472e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 63, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: overflow encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 38, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 53, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 63, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 0}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 28, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: overflow encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 41, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 35, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 43, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 48, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: overflow encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 37, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 51, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 15, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 1, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 24, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 52, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 30}. error: list index out of range
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 44, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 65}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 49, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 54, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 23, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 56, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 30}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 23, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 47, 'coint_rank': 0, 'deterministic': 'lo', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 53, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 38, 'coint_rank': 0, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 58, 'coint_rank': 1, 'deterministic': 'n', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'n', 'seasons': 260}. error: list index out of range
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\statsmodels\tsa\vector_ar\var_model.py:262: RuntimeWarning: invalid value encountered in add
  f = f + np.dot(coefs[i - 1], prior_y)

WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 63, 'coint_rank': 1, 'deterministic': 'lo', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 57, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 57, 'coint_rank': 1, 'deterministic': 'co', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 5}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 37, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 1, 'deterministic': 'colo', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 59, 'coint_rank': 0, 'deterministic': 'li', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 64, 'coint_rank': 0, 'deterministic': 'colo', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 61, 'coint_rank': 0, 'deterministic': 'cili', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 62, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 0}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 32, 'coint_rank': 1, 'deterministic': 'li', 'seasons': 260}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 60, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 260}. error: Singular matrix
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: Input contains NaN, infinity or a value too large for dtype('float64').
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:root:could not evaluate the paramaters: {'lags': 0, 'freq': 'B', 'k_ar_diff': 65, 'coint_rank': 1, 'deterministic': 'cili', 'seasons': 30}. error: list index out of range
WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.772e+03, tolerance: 1.968e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.129e+03, tolerance: 4.288e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.552e+04, tolerance: 9.156e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.907e+02, tolerance: 1.391e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.989e+03, tolerance: 1.971e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.554e+03, tolerance: 4.290e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.270e+04, tolerance: 9.164e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.831e+02, tolerance: 1.391e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.882e+03, tolerance: 1.985e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.142e+03, tolerance: 4.302e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.583e+04, tolerance: 9.196e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.966e+02, tolerance: 1.399e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.397e+03, tolerance: 1.985e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.859e+03, tolerance: 4.301e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.983e+04, tolerance: 9.190e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.778e+02, tolerance: 1.398e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.831e+03, tolerance: 1.972e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.139e+03, tolerance: 4.291e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.575e+04, tolerance: 9.170e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.944e+02, tolerance: 1.392e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.671e+03, tolerance: 1.971e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.897e+03, tolerance: 4.290e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.091e+04, tolerance: 9.168e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.125e+02, tolerance: 1.392e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.679e+03, tolerance: 7.415e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.612e+02, tolerance: 1.336e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.743e+04, tolerance: 3.525e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.290e+02, tolerance: 4.614e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.723e+03, tolerance: 7.441e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 4.390e+02, tolerance: 1.337e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.166e+04, tolerance: 3.533e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.607e+02, tolerance: 4.622e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.776e+03, tolerance: 7.585e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.713e+02, tolerance: 1.350e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.770e+04, tolerance: 3.565e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.338e+02, tolerance: 4.697e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.247e+03, tolerance: 7.583e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.657e+02, tolerance: 1.349e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.479e+04, tolerance: 3.559e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.930e+02, tolerance: 4.692e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.714e+03, tolerance: 7.451e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.665e+02, tolerance: 1.338e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.761e+04, tolerance: 3.539e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.309e+02, tolerance: 4.631e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.317e+03, tolerance: 7.444e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.746e+02, tolerance: 1.337e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.522e+04, tolerance: 3.537e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.027e+02, tolerance: 4.624e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.078e+03, tolerance: 4.244e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.711e+02, tolerance: 7.648e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.616e+03, tolerance: 1.989e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.063e+02, tolerance: 2.187e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.026e+03, tolerance: 4.272e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.286e+02, tolerance: 7.664e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.156e+03, tolerance: 1.997e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.968e+01, tolerance: 2.195e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.189e+03, tolerance: 4.416e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.848e+02, tolerance: 7.788e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.980e+03, tolerance: 2.029e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.120e+02, tolerance: 2.271e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.612e+03, tolerance: 4.414e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.614e+02, tolerance: 7.780e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 6.493e+03, tolerance: 2.024e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.379e+01, tolerance: 2.266e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.124e+03, tolerance: 4.281e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.795e+02, tolerance: 7.674e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 9.886e+03, tolerance: 2.004e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.090e+02, tolerance: 2.203e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.732e+03, tolerance: 4.275e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.807e+02, tolerance: 7.665e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 7.211e+03, tolerance: 2.002e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 8.195e+01, tolerance: 2.197e-02 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.428e+04, tolerance: 3.945e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 2.946e+03, tolerance: 8.060e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.603e+04, tolerance: 1.473e+01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.097e+03, tolerance: 3.052e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.525e+04, tolerance: 4.111e+00 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 3.291e+03, tolerance: 8.826e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 5.841e+04, tolerance: 1.506e+01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\sklearn\linear_model\_coordinate_descent.py:647: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.256e+03, tolerance: 3.472e-01 Linear regression models with null weight for the l1 regularization term are more efficiently fitted using one of the solvers implemented in sklearn.linear_model.Ridge/RidgeCV instead.
  model = cd_fast.enet_coordinate_descent(

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

WARNING:py.warnings:C:\Users\michaelkeith\Anaconda3\lib\site-packages\scalecast\MVForecaster.py:1163: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  observed[col] = (

WARNING:py.warnings:C:\Users\michaelkeith\AppData\Roaming\Python\Python38\site-packages\pandas\core\indexing.py:1684: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self.obj[key] = infer_fill_value(value)

